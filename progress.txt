待做：
72 77 78 88

不做：
44 46 50 52 56 57 60 61 63 66 70 73 74 75 81 83 85

待重做：
43 45 47 48 49 51 53 54 55 58 59 62 64 65 67 68 69 71 72 76 77 78 79 80 82 84 86 87 88

43 
用一个栈缓存当前待处理的数字，遍历表达式的字符，直接从表达式字符串中弹出，并判断类型，如果是数字则累积到缓存变量中
拿到符号后不立刻求解，而是先缓存到变量中，等到下个符号出现时，即右操作数求解完毕后再决定操作
碰到+-号，直接将当前缓存的数字取正或负压入栈中；碰到*/号，需要弹出栈顶的数字，进行计算后再压入栈中
如果碰到左括号，需要递归求解子表达式，碰到下一个右括号，计算好括号内的值并返回，返回的值作为数字压入栈中
上一次的符号计算完成后，再重新初始化符号和数字变量
遍历结束后或右括号返回前将栈中的所有数字相加作为返回值，由于末尾可能是数字，因此当遍历到最后一个字符也要重新求解一次
分数需要做一个新类出来，两个属性分子和分母，每个运算有一个方法，运算后需要计算最大公约数进行约分
特殊情况，比如分子是0或者分母是负数需要单独处理
最大公约数是用辗转相除法得到的，简单讲就是如果大数可以整除小数则小数就是最小公倍数，如果不能则用小数除以这次计算的余数，注意两个数必须要大于0
44 逻辑模拟，简单，跳过
45 
bfs，需要缓存各个方向到该点的时间，迭代时跟据新路径的时间相对于缓存的时间长短判断是否更新缓存及优先队列
heapq库优先队列，压入heappush，弹出heappop，优先弹出小元素，依据为第一个元素大小
directions需要精心设计，这样可以根据偏移量计算相对的方向
46 暴力破解，获取二进制数的个数，可以用bin函数获取，跳过
47
bfs，需要分两次遍历，第一次找到最短时间，第二次找到最多积分
48
二叉树遍历，回溯算法解决，根节点索引0，左子节点2*i+1，右子节点2*i+2
49 dfs
50 滑动窗口算固定区间最大和，题解不对，跳过
51 dfs 题解不对，没那么简单
52 逻辑模拟，跳过
53 
bfs, 先初始化图的连接表，然后设置一个数组用来缓存最大距离，初始化为无穷大
最小堆推入起始点，开始循环，每次弹出一个点并遍历其指向的点
如果距离减小则更新权重并将点序号和距离推到最小堆中，直到堆为空
结束时如果还有节点时间为无穷大则无法访问，否则取最大值为结果
54 二分算法，每次将低的月份与高的月份配对
55 滑动窗口，左指针取值0~目标数一半，右指针取值1~目标数，计算指针间的数字和
56 逻辑模拟，简单题跳过
57 逻辑模拟，题目理解和解法都有问题，跳过
58 滑动窗口，注意以列为单位滑动，用字典存储字符数
59 
bfs 路径相关信息推入堆中，比如是否加过油，第一次加油前的耗油量
全局变量用来剪枝，比如当前点最小的耗油量，全局最小耗油量等
60 逻辑模拟，题目描述稀烂，跳过
61 逻辑模拟，简单，跳过
62 并查集，遍历加入即可解决
63 暴力回溯
64 逻辑模拟，从第一辆车递推即可
65 动态规划，从第0天开始回推金额
66 逻辑模拟，跳过
67 
bfs，需要缓存当前节点最小值，缓存最小的信号并剪枝，通过比较最小信号大小更新
68 
二分查找，完成日期和员工数是相关关系
69
类似于滑动窗口的程序逻辑，用一个数组维护当前剩余的球，每次推入一个球
推入球之后在两端检查能否按照目标顺序拿出球，如果可以的话立刻拿出去
最后如果维护数组里面还有球，就说明无法按照指定的顺序取出
70 IP地址转化为数字之后再进行比较
71 
bfs图遍历，先构建邻接表以及入度，将入度0推入最小堆
遍历最小堆，将邻接表中指向的节点入度-1，如果变为0则推入最小堆，然后继续遍历即可
72 边界条件比较恶心，先跳过节省时间，可以用滑动窗口，不考虑回头路，不考虑边上的山峰，这样做可以节省时间，能通过一部分用例
73 简单排序题，不做，跳过
74 简单题，不做，跳过
75 简单题，根据定义遍历即可，不做，跳过
76 
动态规划，找到递推规律即可，子问题为A和B各行动一轮之后的组合数
由于A和B各能走1-2步，因此一共有四个子问题状态，叠加之后就是当前问题的组合数
初始化dp8=1,dp9=1,后续推导式dpi=dp(i-2)+dp(i-3)*2+dp(i-4)
77 题目和题解都有点问题，后面再做
78 用例太简单了，题解也有点问题，后面再做
79 
hoffman树，把所有节点放入最小堆中升序排序，每次取出值最小的两个两个节点
然后将两个节点放到一个新的公共父节点里面，父节点的值为两个子节点值之和，然后将父节点放到最小堆里面去
依次类推，直到最小堆中只剩下一个节点为止
80 
动态规划，从左上角开始，base case是其中一个字符串为空，那么编辑距离就是另一个字符串的长度
状态转移分为两种情况，第一种是当前位置两个字符不相同，那么只可以考虑上面和左面的dp状态并加一，取最小值
如果相同则可以考虑将左上角的dp状态考虑进来，三者选最小值
81 逻辑模拟，简单题不做
82 
状态压缩+前缀和，将每个特殊字符截止到当前位置是否出现了偶数次映射为一个位的状态
那么出现相同总状态的位置，中间的字符串包含的特殊字符则一定都是偶数个
另外由于是环形字符串，需要用一个数组存储已经出现相同模式的所有索引
索引差小于原始字符串长度且最大的为当前模式下最长的字串，如果大于全局的长度则更新全局长度
83 遍历即可，简单不做
84 双指针遍历一次，返回是否存在即可
85 逻辑模拟，不做
86 
前序和中序遍历结果构建二叉树，根据前序顺序为根-左树-右树及中序左树-根-右树的性质即可恢复原始二叉树
建立一个二叉树的类，遍历过程的参数是构建的数组而不是坐标，这样构建会方便一些
然后后序遍历二叉树更新节点值，最后中序遍历生成结果
87 题解扯犊子，跟N皇后是一类的问题，dfs遍历每一行，根据限制条件剪枝，到达终点更新最小值即可，根本不需要二分图
88 暂时先不做，看不懂
89 打家劫舍问题，动态规划，递推式关系为当前格子数值=前一个格子总和与前面第二个格子综合加上当前格子值的最大值