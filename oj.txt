231 先找到边缘，再对边缘做并查集
242 根据缺的数字减进制，并对数位进行转换
258 找到匹配截止位置
265 元音提取索引再双指针计算
268 排序后扫描查找第一个不一致的，在原数组找最后一个匹配的
282 差分数组求和
320 y在移动到x之后再变，x是实际坐标值而不是变化的坐标值，后续一直移动到终点
334 可以笨方法先拿一定分数。最好的是二进制减法，尽量分配的结果损耗最小
360 定义三叉树类，根据题意递归构建树
365 定义二叉树类，根据二叉树数组表示对应关系，先建立树节点，然后连接树节点，最后遍历树获取结果
367 注意重量为0的不要再加进去了
368 注意输入输出陷阱，满足题目要求
369 升序排序后从起始点双指针，A每轮+1，B增加到刚好差不小于AB之差
372 按照利润率降序，风险升序，排在前面的尽可能多的购买，不够的用后面的填充，按这个规则比较
373 定义树类，按照中序和前序规则递归构建树，如果有重复元素注意比较中序和前序的子树是否一致
376 并查集注意合并时修改的依据是找到的根节点
391 从开始数字开始遍历会导致超时，可以先按照暴力拿分
    效率解法为将二进制串中从右到左第一个01串替换为10，然后将后面的所有1移动到最右侧，代码实现这个字符串逻辑即可
394 优先队列维护滑动窗口内的最大值，先生成当前dp值，然后判断掉滑动窗口左侧的值是否该去掉，最后将当前dp推入滑动窗口
395 二分查找，重新做一遍，熟悉公式
398 并查集+bfs，先将感染人合并，然后将感染人推入队列，遍历队列，将有关联的人关联，并将被关联人推入队列，直到队列变空
    最后所有相关的人都会被合并，独立节点个数-1即为未被感染的人
400 注意有些线段跨度超过1注意归一化处理