231 先找到边缘，再对边缘做并查集
242 根据缺的数字减进制，并对数位进行转换
258 找到匹配截止位置
265 元音提取索引再双指针计算
268 排序后扫描查找第一个不一致的，在原数组找最后一个匹配的
282 差分数组求和
320 y在移动到x之后再变，x是实际坐标值而不是变化的坐标值，后续一直移动到终点
334 可以笨方法先拿一定分数。最好的是二进制减法，尽量分配的结果损耗最小
360 定义三叉树类，根据题意递归构建树
365 定义二叉树类，根据二叉树数组表示对应关系，先建立树节点，然后连接树节点，最后遍历树获取结果
367 注意重量为0的不要再加进去了
368 注意输入输出陷阱，满足题目要求
369 升序排序后从起始点双指针，A每轮+1，B增加到刚好差不小于AB之差
372 按照利润率降序，风险升序，排在前面的尽可能多的购买，不够的用后面的填充，按这个规则比较
373 定义树类，按照中序和前序规则递归构建树，如果有重复元素注意比较中序和前序的子树是否一致
376 并查集注意合并时修改的依据是找到的根节点
391 从开始数字开始遍历会导致超时，可以先按照暴力拿分
    效率解法为将二进制串中从右到左第一个01串替换为10，然后将后面的所有1移动到最右侧，代码实现这个字符串逻辑即可
394 优先队列维护滑动窗口内的最大值，先生成当前dp值，然后判断掉滑动窗口左侧的值是否该去掉，最后将当前dp推入滑动窗口
395 二分查找，重新做一遍，熟悉公式
398 并查集+bfs，先将感染人合并，然后将感染人推入队列，遍历队列，将有关联的人关联，并将被关联人推入队列，直到队列变空
    最后所有相关的人都会被合并，独立节点个数-1即为未被感染的人
400 注意有些线段跨度超过1注意归一化处理
406 根据题意，外层迭代窗口长度，内层迭代窗口编号，外层每结束一次列表索引就+1
    需要注意如果迭代过程中有因为列表元素少导致向后面的列表借元素的情况发生，外层结束时就不需要索引+1
    另外如果内层迭代时发现列表空了也及时删除，有很多陷阱条件，先完成基础的，再根据时间选择是否改进
382 简单做法可以根据滑窗来判断，不过大数会超时。根据数学关系推导，如果目标奇数直接返回中位两数之和
    如果目标是偶数，还要按照数字个数是偶数还是奇数来分别判断，首先要找到最大奇数银子
    如果是偶数，则围绕最大奇数因子周围的是目标序列；如果是奇数个，则需要从3开始依次判断个数，直到个数能够整除为止，就是目标最小个数
    找到个数后确定起点，如果起点小于等于0则排除掉，否则两个个数进行比较，少的就是结果
349 状态压缩，先将数组分为两半，然后用数组长度的二进制位表示是否选中数组
    然后分别统计两个数组选中特定数目元素的和的所有可能，由于规模不大，统计后遍历两边元素互补后所有可能的差值，取最小即可
347 考前记得重新做一遍，过程不符合直觉，需要记住
414 动态规划其他如常，需要记住如果票日期长于当前日期的，递推基准是0而不是不计算
417 栈保存低优先级数据，先保存符号，然后拿到数字，如果符号高优先级，弹出一个栈元素计算，最后按顺序计算低优先级元素即可
423 图算法，bfs+检测入度递推，注意是按层遍历，不是释放后立即加入排序
424 注意对字典序有要求，direction放置需要小的在前面
426 错题，映射关系考前背一下
432 图的入度和出度计算，需要注意使用bfs进行环检测